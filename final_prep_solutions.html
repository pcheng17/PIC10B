<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>final_prep_solutions</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="notes.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<pre><code>\</code></pre>
<h1 id="pic-10b-final-exam-prep-solutions">PIC 10B Final Exam Prep Solutions</h1>
<hr />
<h2 id="more-operation-counting">More operation counting</h2>
<h3 id="section">#1</h3>
<p>Let <span class="math inline">\(T(n)\)</span> be the number of operations needed to print out a binary search tree of <span class="math inline">\(n\)</span> elements. We may write the following expression: <span class="math display">\[ T(n) = \left( 1 + T(n/2) \right) + 1 + \left( 1 + T(n/2) \right) \]</span> where <span class="math inline">\(\left( 1 + T(n/2) \right)\)</span> is the number of operations needed to check if the left child exists, and then if it does, it needs to print approximately half of the tree. The same argument holds for the right child. That extra 1 in the center is from printing out yourself. (Remember, recursive printing should go in the order of left, middle, right.) Thus, <span class="math display">\[\begin{align*}
    T(n) &amp;= 2 \, T(n/2) + 3 \\
         &amp;= 2 \left( 2 \, T(n/4) + 3 \right) + 3 = 2^2 \, T(n/2^2) + 2*3 + 3 \\
         &amp;= 2^2 \left( 2 \, T(n/8) + 3 \right) + 2*3 + 3 = 2^3 \, T(n/2^3) + 2^2 * 3 + 2 * 3 + 3
\end{align*}\]</span> After <span class="math inline">\(k\)</span> steps, the pattern looks like <span class="math display">\[\begin{align*}
    T(n) &amp;= 2^k T(n / 2^k) + 3\left( 1 + 2 + 2^2 + \cdots + 2^{k-1} \right) \\
         &amp;\leq 2^k T(n / 2^k) + 3 * 2^k 
\end{align*}\]</span> Something everything should remember is the mathematical fact I used above to obtain my inequality: <span class="math display">\[ 1 + 2 + 2^2 + \cdots + 2^{k-1} \leq 2^k \]</span> (For the math majors in this class, in the following steps, I’m not going to be mathematically rigorous.) If we let <span class="math inline">\(k = \log_2 n\)</span>, or equivalently, let <span class="math inline">\(n = 2^k\)</span>, we obtain <span class="math display">\[ T(n) \leq n T(2^k / 2^k) + 3 n = n T(1) + 3 n = 4 n \]</span> The final equality is achieved because <span class="math inline">\(T(1) = 1\)</span>. Therefore, <span class="math inline">\(T(n) = O(n)\)</span>, which is exactly what we expected because printing out <span class="math inline">\(n\)</span> elements should take exactly that many operations.</p>
<h3 id="section-1">2</h3>
<p>Let <span class="math inline">\(T(n)\)</span> be the number of operations needed to insert an element into a binary search tree containing <span class="math inline">\(n\)</span> elements. We may write the following expression: <span class="math display">\[ T(n) = 2 + 2 + T(n/2) = 4 + T(n/2) \]</span> where the first 2 comes from the fact that we have to check if data we want to insert is either less than or greater than the node that is currently trying to insert, the second 2 comes from checking if the appropriate child exists, and the final <span class="math inline">\(T(n/2)\)</span> is the amount of work it takes for the next node to insert. Similar to what we saw above, the reason why it’s <span class="math inline">\(n/2\)</span> is because the child should own approximate half of the remaining elements.</p>
<p>If you look at the solution for the ternary search problem below, (#2 in the harder problems section) this expression is pretty much the same expression! The constant might be different, but that doesn’t change anything. We’re also dividing by 2 here as opposed to the 3 we see below, but that doesn’t change the work at all. Therefore, <span class="math inline">\(T(n) = O(\log n)\)</span>.</p>
<p>This is exactly what we expect because in order for us to insert something into a binary search tree, we need to first do a search to make sure that the number doesn’t exist. In order to figure out that it doesn’t exist, we must’ve found our way to the position in the tree where it should exist. If it doesn’t, then we just insert a new node in that position.</p>
<h2 id="easier-problems">Easier problems</h2>
<h3 id="section-2">#1</h3>
<p>This problem boils down to remembering the duality law for pointers/arrays, which is that, if <span class="math inline">\(a\)</span> is an array, then</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" data-line-number="1">a[i] == *(a + i)</a></code></pre></div>
<p>This also works if <span class="math inline">\(i\)</span> is a negative number, assuming that the pointer <span class="math inline">\(a+i\)</span> still points to a position in the array. This would happen in cases where the pointer <span class="math inline">\(a\)</span> doesn’t point to the beginning of an array.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    <span class="dt">int</span> a[] = {<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>};</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    <span class="dt">int</span>* arr = a + <span class="dv">3</span>;</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    arr[<span class="dv">-2</span>] = <span class="dv">-2</span>;                       <span class="co">// {1, -2, 3, 4}                    </span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    *(arr--) = <span class="dv">6</span>;                       <span class="co">// {1, -2, 3, 6}</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    arr[<span class="dv">1</span>] = <span class="dv">0</span>;                         <span class="co">// {1, -2, 3, 0}</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    *(arr<span class="dv">-2</span>) = <span class="dv">10</span>;                      <span class="co">// {10, -2, 3, 0}</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">    <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; <span class="dv">4</span>; ++i) {</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">        <span class="bu">std::</span>cout &lt;&lt; a[i] &lt;&lt; <span class="st">&quot; &quot;</span>;       <span class="co">// Output: 10 -2 3 0</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">    }               </a>
<a class="sourceLine" id="cb3-12" data-line-number="12">    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">}</a></code></pre></div>
<h3 id="section-3">#2</h3>
<p>In the palindrome checker for strings, we avoid the use of the substring function because that automatically forces us to make extra unnecessary copies of portions of the input string. Instead, we can easily tell the helper function to just check letters on both sides of the string by specifying the appropriate indices.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="dt">bool</span> is_palindrome(<span class="at">const</span> <span class="bu">std::</span>string&amp; s) {</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">    <span class="cf">return</span> is_palindrome_helper(<span class="dv">0</span>, s.length()<span class="dv">-1</span>, s);</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="dt">bool</span> is_palindrome_helper(<span class="dt">size_t</span> start, <span class="dt">size_t</span> end, <span class="at">const</span> <span class="bu">std::</span>string&amp; s) {</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    <span class="cf">if</span> (start &gt;= end) { </a>
<a class="sourceLine" id="cb4-7" data-line-number="7">        <span class="cf">return</span> <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    } <span class="cf">else</span> <span class="cf">if</span> (s[start] == s[end]) {</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">        <span class="cf">return</span> is_palindrome_helper(++start, --end, s);</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">        <span class="cf">return</span> <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">}</a></code></pre></div>
<p>Here is the extra function needed to check if an integer is a palindrome (using the functions above):</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;sstream&gt;</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="dt">bool</span> is_palindrome(<span class="dt">int</span> n) {</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    <span class="bu">std::</span>ostringstream os;</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    os &lt;&lt; n;</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    <span class="cf">return</span> is_palindrome(os.str());</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">}</a></code></pre></div>
<p>The operation count of the palindrome checker for strings is as follows. Let <span class="math inline">\(T(n)\)</span> be the number of operations required to check if a string of <span class="math inline">\(n\)</span> letters is a palindrome. Then, in the worst case scenario, <span class="math display">\[ T(n) = 3 + T(n-2) \]</span> where the 3 comes from accessing the first letter, the last letter, and comparing them, and <span class="math inline">\(T(n-2)\)</span> is from the recursive call on a string of two letters less. Note that no copies are ever made in my version of the helper function. If copies were made, every letter that gets copied would add an extra operation to the operation count. We now unravel the expression above for <span class="math inline">\(T(n)\)</span> above to obtain <span class="math display">\[\begin{align*}
    T(n) &amp;= T(n-2) + 3\\
         &amp;= \left( T(n-4) + 3 \right) + 3 = T(n - 4) + 6 = T(n - 2*2) + 2*3 \\
         &amp;= \left( T(n-6) + 3 \right) + 6 = T(n - 6) + 9 = T(n - 2*3) + 3*3 \\
         &amp;= \left( T(n-8) + 3 \right) + 9 = T(n - 8) + 12 = T(n - 2*4) + 4*3 \\
         &amp;= \dots \\
         &amp;= T(n - 2k) + k*3 = T(n - 2k) + 3k
\end{align*}\]</span> The last line is what happens if we continue the pattern for <span class="math inline">\(k\)</span> steps. Hence, if we let <span class="math inline">\(k = n/2\)</span>, then <span class="math display">\[ T(n) = T\left(n - 2(n/2)\right) + 3\frac{n}{2} = T(0) + 3 \frac{n}{2}\]</span> <span class="math inline">\(T(0)\)</span> is simply just 0 (because no work needs to be done to check if a string of length 0 is a palindrome), which yields <span class="math display">\[ T(n) = 3\frac{n}{2} = \frac{3}{2} n \]</span> Therefore, <span class="math inline">\(T(n) = O(n)\)</span>. Remember, this is the operation count for the worst-case scenario. Obviously, in many cases, we can do much better than this if the string isn’t a palindrome (since in these cases the checking can stop early). Furthermore, the fact that checking whether or not a string is a palindrome is <span class="math inline">\(O(n)\)</span> shouldn’t be surprising. This is basically saying that, at worst, we need to visit every letter of a string in order to make sure it’s a palindrome (or not).</p>
<h3 id="section-4">#3</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">class</span> Shape</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    <span class="co">// Optional: default constructor</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    <span class="co">// Remember, lack of any constructors means the compiler will give</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="co">// us the default constructor for free</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">    <span class="co">// Needs virtual destructor</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">    <span class="kw">virtual</span> ~Shape() {}</a>
<a class="sourceLine" id="cb6-10" data-line-number="10"></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    <span class="co">// Needs to be declared virtual</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">    <span class="kw">virtual</span> <span class="dt">double</span> getArea() <span class="at">const</span> { <span class="cf">return</span> <span class="fl">0.0</span>; }</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">};</a>
<a class="sourceLine" id="cb6-14" data-line-number="14"></a>
<a class="sourceLine" id="cb6-15" data-line-number="15"><span class="co">// Needs to be public inheritance </span></a>
<a class="sourceLine" id="cb6-16" data-line-number="16"><span class="kw">class</span> Rectangle : <span class="kw">public</span> Shape</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">{</a>
<a class="sourceLine" id="cb6-18" data-line-number="18"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb6-19" data-line-number="19">    <span class="co">// Needs default constructor OR default values in constructor with parameters</span></a>
<a class="sourceLine" id="cb6-20" data-line-number="20">    <span class="co">// Needs to default construct base Shape object</span></a>
<a class="sourceLine" id="cb6-21" data-line-number="21">    Rectangle(<span class="dt">double</span> l = <span class="fl">0.0</span>, <span class="dt">double</span> w = <span class="fl">0.0</span>) : Shape(), length(l), width(w) {}</a>
<a class="sourceLine" id="cb6-22" data-line-number="22"></a>
<a class="sourceLine" id="cb6-23" data-line-number="23">    ~Rectangle() {}     <span class="co">// optional</span></a>
<a class="sourceLine" id="cb6-24" data-line-number="24"></a>
<a class="sourceLine" id="cb6-25" data-line-number="25">    <span class="co">// Getters should all be const</span></a>
<a class="sourceLine" id="cb6-26" data-line-number="26">    <span class="dt">double</span> getArea() <span class="at">const</span> { <span class="cf">return</span> length * width; }</a>
<a class="sourceLine" id="cb6-27" data-line-number="27">    <span class="dt">size_t</span> getNumberOfSides() <span class="at">const</span> { <span class="cf">return</span> <span class="dv">4</span>; } </a>
<a class="sourceLine" id="cb6-28" data-line-number="28"></a>
<a class="sourceLine" id="cb6-29" data-line-number="29">    <span class="co">// Must be declared friend because of the lack of accessors</span></a>
<a class="sourceLine" id="cb6-30" data-line-number="30">    <span class="co">// std::ostream must be passed and returned by reference </span></a>
<a class="sourceLine" id="cb6-31" data-line-number="31">    <span class="kw">friend</span> <span class="bu">std::</span>ostream&amp; <span class="kw">operator</span>&lt;&lt;(<span class="bu">std::</span>ostream&amp; os, <span class="at">const</span> Rectangle&amp; rhs);</a>
<a class="sourceLine" id="cb6-32" data-line-number="32"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb6-33" data-line-number="33">    <span class="dt">double</span> length, width;</a>
<a class="sourceLine" id="cb6-34" data-line-number="34">};</a>
<a class="sourceLine" id="cb6-35" data-line-number="35"></a>
<a class="sourceLine" id="cb6-36" data-line-number="36"><span class="co">// std::ostream must be passed and returned by reference</span></a>
<a class="sourceLine" id="cb6-37" data-line-number="37"><span class="bu">std::</span>ostream&amp; <span class="kw">operator</span>&lt;&lt;(<span class="bu">std::</span>ostream&amp; os, <span class="at">const</span> Rectangle&amp; rhs) {</a>
<a class="sourceLine" id="cb6-38" data-line-number="38">    <span class="co">// Must write rhs.length to access the length member variable of rhs</span></a>
<a class="sourceLine" id="cb6-39" data-line-number="39">    <span class="co">// Same thing with width</span></a>
<a class="sourceLine" id="cb6-40" data-line-number="40">    os &lt;&lt; rhs.length &lt;&lt; <span class="st">&quot; x &quot;</span> &lt;&lt; rhs.width &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb6-41" data-line-number="41">    <span class="cf">return</span> os;</a>
<a class="sourceLine" id="cb6-42" data-line-number="42">}</a></code></pre></div>
<h2 id="harder-problems">Harder problems</h2>
<h3 id="section-5">#1</h3>
<p>The issue with the first snippet is that we never refresh the iterator that we passed into the erase function. After the erase function finishes, the iterator we passed in is no longer pointing at anything, rendering it invalid. Thus, if we try to increment the same iterator, which this version does, we get unpredictable behavior. If you think back to the homework assignment on lists, you’ll remember that the erase function took in an iterator and also returned an iterator, which would be an iterator pointing at the next element in the container. Now, you might be wondering why we never really had his discussion regarding our binary search tree homework. Well, for our binary search tree, we implemented an erase function that took, as input, an integer to erase as opposed to an iterator pointing the the TreeNode to erase! Hence, our binary search trees will ever run into the issue of prodcing invalid iterators during erasing - there’s no iterator to invalidate!</p>
<p>The second snippet fixes the issue of the invalidated iterator because it uses the fact that the erase function returns a fresh iterator pointing at the next object in the set, and this is exactly the source of the error. If erasing happened, then our iterator is automatically moved to the next element in our set, which is fine, but the for loop is ALSO incrementing the iterator as well! Hence, every time erasing happens, our iterator will actually get moved forward twice. In this specific context, it actually turns out that the code will still remove all even numbers (since all even numbers are two away from each other), but this obviously isn’t what we intended.</p>
<p>There are many different ways to fix it. Here’re two possible ways:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="cf">for</span> (<span class="kw">auto</span> it = numbers.begin(); it != numbsrs.end(); ++it) {</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">    <span class="cf">if</span> (*it % <span class="dv">2</span> == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">        it = numbers.erase(it);</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">        --it;   </a>
<a class="sourceLine" id="cb7-5" data-line-number="5">        <span class="co">// Move the iterator backwards by one to counter the fact that erase will</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">        <span class="co">// automatically move the iterator up by one</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">}</a></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">auto</span> it = numbers.begin(), end = numbers.end();</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="cf">while</span> (it != end) {</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    <span class="cf">if</span> (*it % <span class="dv">2</span> == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">        it = numbers.erase(it);     <span class="co">// Automatically moves the iterator forward</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">        <span class="co">// No erase happened, so we must move the iterator ourselves</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">        ++it;</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">}</a></code></pre></div>
<p>I like the second one more because there’s no weirdness of having to decrease the iterator inside a loop that’s supposed to be incrementing the iterator.</p>
<h3 id="section-6">#2</h3>
<p>Ternary search is the same complexity as binary search. The expression for the operation count we start off will be something like <span class="math display">\[ T(n) = T(n/3) + O(1) \quad \text{or} \quad T(n) = T(n/3) + k \]</span> where <span class="math inline">\(k\)</span> is some contant independent of <span class="math inline">\(n\)</span> that includes the operations required to calculate the indices associated with each third of the vector and the associated comparisions to determine in which third the number of interest is. It’s hard to count exactly how many extra operations there are in the <span class="math inline">\(k\)</span> term, but it’s at least 6 (in the worst case scenario) and definitely not as many as <span class="math inline">\(n\)</span>. I’m not going to flesh out the work, but here’s what the end of it looks like. Eventually, you’ll get <span class="math display">\[ T(n) = T(n / 3^m) + mk \]</span> where <span class="math inline">\(m\)</span> represents the number of times we’ve applied the recursive pattern. Now, let <span class="math inline">\(n = 3^m\)</span>, or equivalently, <span class="math inline">\(m = \log_3(n)\)</span>. Making all of these substitutions and using the fact that <span class="math inline">\(T(1)=1\)</span> (searching a vector of one element requires exactly one check) yields <span class="math display">\[\begin{align*}
    T(n) &amp;= T(3^m/3^m) + k \log_3(n) \\
         &amp;= T(1) + k \log_3(n) \\
         &amp;= 1 + k \log_3(n) \\
         &amp;= O(\log n)
\end{align*}\]</span> Nope, the base of the log doesn’t matter. :)</p>
<h3 id="section-7">#3</h3>
<p>Mark should implement his own string class that overloads the <span class="math inline">\(&lt;\)</span> operator so it compares instances of his string class with respect to their lengths. The following would be sufficient.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">class</span> MyString </a>
<a class="sourceLine" id="cb9-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    MyString(<span class="at">const</span> <span class="bu">std::</span>string&amp; s = <span class="st">&quot;&quot;</span>) : str(s) {}</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    <span class="bu">std::</span>string getString() <span class="at">const</span> { <span class="cf">return</span> str; }</a>
<a class="sourceLine" id="cb9-7" data-line-number="7"></a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">    <span class="bu">std::</span>string str;</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">}</a>
<a class="sourceLine" id="cb9-11" data-line-number="11"></a>
<a class="sourceLine" id="cb9-12" data-line-number="12"><span class="dt">bool</span> <span class="kw">operator</span>&lt;(<span class="at">const</span> MyString&amp; lhs, <span class="at">const</span> MyString&amp; rhs) {</a>
<a class="sourceLine" id="cb9-13" data-line-number="13">    <span class="cf">return</span> lhs.getString().length() &lt; rhs.getString().length(); </a>
<a class="sourceLine" id="cb9-14" data-line-number="14">}</a></code></pre></div>
<p>With this, an instance of <span class="math inline">\(\text{std::set&lt;MyString&gt;}\)</span> will automatically sort strings with respect to their lengths. Mark can still use all of the member functions of the std::string class (like substr(), length(), find(), etc) by first calling the accessor on his MyString instance to get the std::string itself. Also, note that because of the accessor, we don’t need to declare the <span class="math inline">\(&lt;\)</span> operator as a friend of MyString.</p>
<h3 id="section-8">#4</h3>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co">// Overload to handle Integer + int</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">Integer <span class="kw">operator</span>+(<span class="at">const</span> Integer&amp; lhs, <span class="dt">int</span> rhs) {</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    Integer rhs_clone(rhs);     <span class="co">// Construct an Integer version of rhs</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    <span class="cf">return</span> lhs + rhs_clone;     <span class="co">// Already have operator+ for two objects of type Integer</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="co">// Overload to handle int + Integer</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">Integer <span class="kw">operator</span>+(<span class="dt">int</span> lhs, <span class="at">const</span> Integer&amp; rhs) {</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">    <span class="cf">return</span> rhs + lhs;           <span class="co">// Switch the order of addition to use the above :)</span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10">}</a></code></pre></div>
<h3 id="section-9">#5</h3>
<p><a href="http://pcheng17.github.io/Code/final_exam_5.cpp">Here</a> is my main source file so you can just download and run it. If you’re going to read in from integers100000.txt, make sure that you’ve already downloaded the file into the right location so either XCode or Visual Studios can find it.</p>
<p>I’ve provided three versions of possible solutions, a slow version, a medium-speed version, and a fast version. I think most people will be able to come up with one of the three. None of them use explicitly recursive, but we can still find the cost of each approach simply by analyzing the for-loops involved and counting the number of operations. The slow version is <span class="math inline">\(O(n^2)\)</span>, the medium version is <span class="math inline">\(O(n \log n)\)</span>, while the fast version is <span class="math inline">\(O(n)\)</span>. If you run all of them on the contents of integers100000.txt (the code I posted already does this, so you can just run it), you’ll notice a difference in their speeds. Since <span class="math inline">\(n\)</span> isn’t that large, the <span class="math inline">\(O(n \log n)\)</span> and <span class="math inline">\(O(n)\)</span> versions will seem like the run almost at the same speed. However, the <span class="math inline">\(O(n^2)\)</span> version is extremely slow. It might seem like the program froze, but in reality, it’s just really really slow because it needs to perform approximately <span class="math inline">\(10^{10}\)</span> operations.</p>
<h3 id="section-10">#6</h3>
<p><a href="http://pcheng17.github.io/Code/final_exam_6.cpp">Here</a> is the main source file. Same spiel as above regarding reading in from numbers.txt.</p>
<p>I only provided one solution for this problem (out of potentially many different versions). It’s not the most efficient way possible (operation-count wise), but I think it’s the solution worth knowing for the purpose of reviewing the useful of different data structures. It’s a little hard to find the operation count because sorting via insertion into a set isn’t truly <span class="math inline">\(O(n \log n)\)</span> since we sort each number as they’re being inserted as opposed to sorting the entire collection at once. However, we can definitely say it’s at least <span class="math inline">\(O(n)\)</span> (since we traverse through the entire set once), and at most <span class="math inline">\(O(n \log n)\)</span> (because of sorting).</p>
</body>
</html>
